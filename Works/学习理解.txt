Redis 和 MySQL
	mysql是持久化存储，存放在磁盘里面，检索的话，会涉及到一定的IO，为了解决这个瓶颈，于是出现了缓存，比如现在用的最多的 memcached(简称mc)。首先，用户访问mc，如果未命中，就去访问mysql，之后像内存和硬盘一样，把数据复制到mc一部分。

　　redis和mc都是缓存，并且都是驻留在内存中运行的，这大大提升了高数据量web访问的访问速度。然而mc只是提供了简单的数据结构，比如 string存储；redis却提供了大量的数据结构，比如string、list、set、hashset、sorted set这些，这使得用户方便了好多，毕竟封装了一层实用的功能，同时实现了同样的效果，当然用redis而慢慢舍弃mc。
	推理到redis+mysql，它是内存+磁盘关系的一个映射，mysql放在磁盘，redis放在内存，这样的话，web应用每次只访问redis，如果没有找到的数据，才去访问Mysql。
	前者是内存数据库，数据保存在内存中，当然速度快。
后者是关系型数据库，功能强大，数据访问也就慢。

Ruby
	我们经常需要在执行性能与开发效率上做取舍
	性能的问题，等你真正遇到了再去解决；能快速做出产品才是优先考虑的
	Ruby和Python都是牺牲性能管来开发效率
	创业公司用ROR快速实现想法。等到你的用户群达到出现效率问题的时候，再来考虑优化。好的优化和缓存机制，能顶很长时间。javaeye就是好的例子
	Ruby （甚至1.9）性能的确不佳（比如不如 Python），但如果是做 web 开发，本身性能并不关键，I/O 才是瓶颈。
	处理 web 请求属于 “embarrassingly parallelizable” 的问题，可以通过增加硬件解决 scaling 问题。此种情况下，Ruby 的动态语言特性和成熟的 Rails 框架带来的开发效率的提升更有价值。