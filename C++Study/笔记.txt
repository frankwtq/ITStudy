C++primer plus
内联函数 inline
引用变量 int & 只能在声明时赋初值；
默认参数
函数重载
函数模板 template<typename T> or template<class T>
对象和类 类成员函数声明和定义；构造函数和析构函数
############################################
对一个变量int x；来说，x=1后，x指的就是地址0000H，当使用x时，如cout<<x;这个过程是：将x这个地址指向的地址单元中的内容取
出来用，如同直接寻址一样。而cout<<&x就是输出x本身。
对一个指针变量int *x；来说，x也是地址0001H，所以cout<<x的过程是，将x这个地址0001H指向的地址单元中的内容0000H取出来用，
而cout<<*x就是将x这个地址0001H指向的地址单元中的内容0000H作为地址所指向的地址单元中的内容1取出来用。而cout<<&x就是
输出0001H；
############################################
当用指针变量作为函数形参时，如
int *A=NULL;
fun（int *a）;
main()
{
	fun(A);
}
这是传入到形参a的是将A本身地址0001H所指向的地址单元中的0000H给了a本身地址（假设是0004H）所指向的地址单元中；
这时，如果对a进行
a=(int *)malloc(sizeof(int *) );
操作时，a本身地址0004H所指向的地址单元中的内容就会从0000H变为一个新的地址（由于malloc原因，假设为0003H）。
但A本身地址0001H所指向的地址单元中还是0000H，不会变为0003H;
只有将fun(int *a)改为fun(int *&a)才行。
这时由于每种原因，p本身的地址会变为A本身的地址，操作p就是操作A了。
#################################
注意在结构体
struct Link
{
	int data;
	Link * next ;
}
使用时，
Link *L;
L->next=(Link*)malloc(sizeof(Link *));
一定要在
L=L->next；
之前，否则上一个结构体就无法链接到下一个结构体；
如果在之前的话，由于新建的结构体中的next默认都是没有分配存储单元的，这一地址对应的地址单元是不能使用的，只能为其用
malloc开辟空间，由于malloc开辟的空间的首地址是不确定的，基本不可能是原来next指向的地址，这样，新地址就会覆盖掉原来L
指向的next的地址，而原结构体中的next不会发生改变。
例如：
Link *L;
以L地址单元指向的地址为首地址，会有结构体对应大小的空间可以使用，此时：
   L（0010H）		存储：0001H
data（0001H）		存储：1
next（0002H）		存储：0004H  

    （0004H）           存储：xxxx  以此为首地址，不一定有足够存储单元供结构体存储
可以向其中的data（0001H）赋值：
L->data=1；也可以向next（0002H）赋地址，但赋的地址所对应的空间不一定有结构体对应大小的空间可以使用。所以我们需要用malloc开辟一个空间，然后将
开辟空间的首地址赋值（0003H）给next（0002H）。此时：
   L（0010H）		存储：0001H
data（0001H）		存储：1
next（0002H）		存储：0003H

    （0003H） 		存储：xxxx    以此为首地址，之后的几个存储单元都可用，可供结构体存储。
此时可再使用L=L->next；
   L（0010H）		存储：0003H
data（0001H）		存储：1
next（0002H）		存储：0003H

   （0003H） 		存储：xxxx    以此为首地址，之后的几个存储单元都可用，可供结构体存储。
若在malloc前先使用了
L=L->next；则：
   L（0010H）		存储：0004H
data（0001H）		存储：1
next（0002H）		存储：0004H  

    （0004H）           存储：xxxx    以此为首地址，不一定有足够存储单元供结构体存储
后使用malloc：
L=L->next；则：
   L（0010H）		存储：0003H
data（0001H）		存储：1
next（0002H）		存储：0004H  

    （0004H）           存储：xxxx    以此为首地址，不一定有足够存储单元供结构体存储
    （0003H） 		存储：xxxx    以此为首地址，之后的几个存储单元都可用，可供结构体存储。
虽然L指向了0003H但之前的结构体中的next指向的却是0004H而不是0003H这样上一个结构体就和当前的L断链了。